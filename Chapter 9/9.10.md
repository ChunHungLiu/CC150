> 所有的解决方案都在牛客网在线测试：[程序员面试金典](http://www.nowcoder.com/ta/cracking-the-coding-interview)。

> 如果发现错误，希望你能帮我给我创建一个Issue：[在这里创建Issue](https://github.com/Shitaibin/CC150/issues)，谢谢。



## 堆箱子

> 有一堆箱子，每个箱子宽为wi，长为di，高为hi，现在需要将箱子都堆起来，而且为了使堆起来的箱子不到，上面的箱子的宽度和长度必须大于下面的箱子。请实现一个方法，求出能堆出的最高的高度，这里的高度即堆起来的所有箱子的高度之和。
给定三个int数组w,l,h，分别表示每个箱子宽、长和高，同时给定箱子的数目n。请返回能堆成的最高的高度。保证n小于等于500。

### 限制

1. 长宽高，输入数据为整数。
1. 上面的箱子的宽度和长度必须大于下面的箱子（书上要求长宽高）。
1. n <= 500。

### 测试数据

```
vector<int> w({2768,542,832,844,2920,587,72,1724,447,809,672,2393,1235,2775,273,1165,1809,111,1263,2751,1068,2507,453,65,2338,1103,1093,2327,1995,1125,2340,1133,2123,1692,2215,140,1822,2144,2240,2916,1860,2226,698,846,2177,295});
vector<int> l({821,2593,1581,2891,2853,1662,2747,2856,2178,865,383,523,809,998,312,237,1871,2730,823,676,568,1839,2063,1651,2704,2113,1316,2892,1874,270,1112,869,1099,1876,371,2298,2070,1514,2916,165,1043,1355,2852,1319,1979,1961});
vector<int> h({771,2963,1599,1910,2317,2884,872,2463,949,341,2718,1500,1071,539,2463,1355,104,2989,1240,240,981,0,2172,3011,621,681,1178,2518,2766,615,460,2399,2443,2894,799,1726,2454,2099,2279,2911,2018,426,2896,224,2663,351});

结果20722
```

### 方案1：DP


先按宽度排序，逆序，保证前面的箱子可能是后面箱子的底。

定义F(n)为以n为顶（结尾）的最大高度，那么向里面再加一个箱子的时候，依赖于前面n个箱子的结果，只能加在符合条件的一个上面。
F(i) = h(i) + max{F(j) | w[j] > w[i], l[j] > l[i], 0 <= j <= i-1}
F(0) = h(0)
结果是max{F(i)| 0 <= i < n}。

由于这个题目与计算所有F(i)的时间复杂度为O(N^2)，我们排序时采用冒泡排序也是可以接受的，如果输入的参数是结构体，可以使用快速排序。

时间复杂度：O(N^2)，空间复杂度：O(N)。



```C
class Box {
    int f[501] = {0};
public:
    int getHeight(vector<int> w, vector<int> l, vector<int> h, int n) {
    	// Bubble Sort
        for (int i = w.size() - 1; i > 0; i--) {
            for (int j = w.size() - 1; j > w.size() - 1 - i; j--) {
                if (w[j] > w[j-1]) {
                    swap(w[j], w[j-1]);
                    swap(l[j], l[j-1]);
                    swap(h[j], h[j-1]);
                }
            }
        }

        // Debug
    //    for (int i = 0; i < w.size(); i++) {
    //        cout << w[i] << " " << l[i] << " " << h[i] << endl;
    //    }

        f[0] = h[0];
        int maxHeight = f[0];
        for (int i = 1; i < n; i++) {
            f[i] = h[i];
            int tMax = 0;
            for (int j = i-1; j >= 0; j--) {
                if (w[j] > w[i] && l[j] > l[i]) {
                    tMax = max(tMax, f[j]);
                }
            }
            f[i] += tMax;
            maxHeight = max(maxHeight, f[i]);
        }
        return maxHeight;
    }
};
```
